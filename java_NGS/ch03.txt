연산자
- 연산을 수행하는 기호

피연산자
- 연산자의 연산 수행 대상

모든 연산자는 연산결과를 반환

연산자의 종류
- 산술 연산자 : + - * / % (사칙연산과 나머지 연산)
- 비교 연산자 : > < >= <= == != (크고 작음과 같고 다름을 비교)
- 논리 연산자 : && || (그리고와 또는으로 조건을 연결)
- 대입 연산자 : = (우변의 값을 좌변에 저장)
- 기타 : (type) ? : instanceof (형변환 연산자, 삼항 연산자, instanceof 연산자)

연산자의 우선순위
- 하나의 식에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는것
- 산술 > 비교 > 논리 > 대입, 대입은 제일 마지막에 수행
- 단항(1) > 이항(2) > 삼항(3), 단항 연산자의 우선순위가 이항 연산자보다 높음

연산자의 결합규칙
- 대입과 단항 연산자를 대회하면 모두 왼쪽에서 오른쪽으로

증감 연산자
- 증가 연산자(++) : 피연산자의 값을 1 증가시킴
- 감소 연산자(--) : 피연산자의 값을 1 감소시킴
- 전위형 : 값이 참조되기 전에 증가시킴
- 후위형 : 값이 참조된 후 증가시킴

증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없음

부호 연산자
- '-'는 연산자의 부호를 반대로 변경
- '+'는 아무런 일도 하지 않음(사용X)

형변환 연산자
- 형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- 형변환 이유 : 서로 다른 두 타입을 일치시키기 위해서
- 자동형변환 : 컴파일러가 자동으로 형변환, 기존의 값을 최대한 보존할 수 있는 타입으로
- byte b = 100;
  byte b = (byte)100; 
- int i = 100;
  byte b = i; // 에러
  byte b = (byte)i; // byte타입으로 형변환
- byte b = 1000; // 에러
  byte b = (byte)1000; // 값 손실이 발생하여 -24가 저장됨
  
산술 변환
- 연산 전에 피연산자의 타입을 일치시키는것
- 두 연산자의 타입을 같게 일치시킴(보다 큰 타입으로)
  피연산자의 타입이 int보다 작은 타입이면 int로 변환
- long + int → long + long → long
  float + int → float + float → float
  double + float → double + double → double
  
반올림 Math.round()
- 실수를 소수점 첫째자리에서 반올림한 정수를 반환

나머지 연산자 %
- 오른쪽 피연산자로 나누고 남은 나머지를 반환
- 나누는 피연산자는 0이 아닌 정수만 허용(부호는 무시)

비교연산자 >, <, <=, >=, ==, !=
- 두연산자를 비교해서 true 또는 false를 반환

문자열의 비교
- == 대신 equals() 사용
- String str1 = new String("abc");
  String str2 = new String("abc");
  System.out.println(str1 == str2); // false
  System.out.println(str1.equals(str2)); // true
  
논리 연산자
- 조건식을 연결할 때 사용하는 연산자
- ||(OR결합) 피연산자 중 어느 한 쪽이 true면 true
- &&(AND결합) 피연산자 중 양 쪽이 true면 true

논리 부정 연산자 !
- true를 false로, false를 true로 바꿈

조건 연산자 ? :
- 조건식의 결과에 따라 연산결과를 달리함

대입 연산자
- 오른쪽 피연산자를 왼쪽 피연산자에 저장한 후 저장된 값을 반환
- lvalue : 왼쪽 피연산자, rvalue : 오른쪽 피연산자
- int i = 0;
  3 = i + 3; // 에러, lvalue는 값을 저장할 수 있는 공간이 아님
  i + 3 = i; // 에러, lvalue의 연산 결과가 리터럴

복합 대입 연산자
- 대인 연산자와 다른 연산자를 하나로 축약
- i = i + 3; → i += 3;
- i = (i * (10 + j)); → i *= 10 + j;